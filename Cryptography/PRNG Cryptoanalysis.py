"""
Challenge link: https://www.hackerrank.com/challenges/prng-sequence-guessing

This file simulates the basic version of java prng nextInt(1000) of the class Random
As input, the code expects the number of test cases followed by a list of space separated integers in the domain of
0<=x<1000 which represent an output of 10 runs of nextInt(1000) in Java.
The code computes the seed according to the outputs provided, and lists the next 10 runs of nextInt(1000).

The attack on the prng algorithm uses the following properties:
The seed is a 48 bit integer, which we can separate to the following brackets: 28 bits | 3 bits | 17 bits

1. The chinese remainder theorem implies that if y = x (mod 1000) then y = x (mod 8), thus the middle 3 bits of the
output generation are directly leaked.

2. The lower 17 bits can be bruteforced according to our list of outputs in a reasonably short amount of time

3. The remaining higher 28 bits can be generated by using the following formula in a reasonably short time:
input = (seed//2^17) mod 1000 => first_input + lower_17_bits + 1000*i = seed


Constraints assumed for hackerrank successful runtime:
1<=N<=10
"""

from fileinput import input

lines = input()
n =int(lines[0].strip())
rand = []
outputsArray=[]
for i in range(1,n+1):
    outputsArray.append([int(x) for x in lines[i].split( )])

def next_seed(seed, mask=2 ** 48):
    return (multiplier*seed+additive) % mask

def next_seed_and_output(seed, mod, mask=2 ** 48):
    seed = next_seed(seed, mask)
    return seed, next_output(seed, mod, mask)

def next_output(seed, mod, mask=2 ** 48):
    return (seed // (2**17))%mod

def generate_outputs(initialSeed, mod, count, mask=2 ** 48):
    output=[]
    seed = initialSeed
    for i in range(count):
        seed,o = next_seed_and_output(seed, mod, mask)
        output.append(o)
    return output

def generate_seeds_for_outputs(initialSeed, mod, count, mask=2 ** 48):
    output=[]
    seed = initialSeed
    for i in range(count):
        seed,o = next_seed_and_output(seed, mod, mask)
        output.append(seed)
    return output

def get_lower_20_bits(topBits):
    for i in range(2**17):
        seed = topBits*(2**17) + i
        rightSeed = True
        for o in outputsmod8:
            seed,output = next_seed_and_output(seed, 8, 2 ** 20)
            if (output!=o):
                rightSeed = False
                break
        if rightSeed:
            low20bits = topBits * (2 ** 17) + i
            break
    return low20bits

multiplier = a = 0x5DEECE66D
additive = b = 0xB

for o in outputsArray:
    first = o[0]
    mod125 = first%125
    seeds = generate_seeds_for_outputs(2 ** 48 - 1, 1000, 10)
    outputs = o
    outputsmod8 = [x % 8 for x in outputs]
    generated=False
    power = 3
    x=0
    low20bits=0

    topBits = outputsmod8[0]
    outputsmod8 = outputsmod8[1:]
    S1 = get_lower_20_bits(topBits, outputsmod8)

    low20bits = S1
    low = low20bits%(2**17)
    high = 0
    s0 = outputs[0]
    outputs = outputs[1:]
    precompute = s0*(2**17) + low
    i=0

    # find the remaining bits
    while i*1000<=2**31:
        seed = precompute + i*125*(2**20)

        rightSeed = True
        for o in outputs:
            seed, output = next_seed_and_output(seed, 1000)
            if (output != o):
                rightSeed = False
                break
        if rightSeed:
            break
        i+=1

    if rightSeed:
        guess = ""
        for i in range(10):
            seed,o = next_seed_and_output(seed, 1000)
            guess += str(o) + " "

        print(guess)
    else:
        print("search failed")